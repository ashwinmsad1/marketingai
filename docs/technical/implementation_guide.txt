# Implementation Guide
## AI Marketing Automation Platform

---

## 1. OVERVIEW

### Purpose
This implementation guide provides development patterns, coding standards, and best practices for building the AI Marketing Automation Platform. For detailed environment setup instructions, see `docs/development/environment_setup.txt`.

### Prerequisites
Before following this guide, ensure you have completed the development environment setup as outlined in the environment setup documentation.

### Key Principles
- **Consistency**: Follow established patterns throughout the codebase
- **Maintainability**: Write code that is easy to understand and modify
- **Performance**: Optimize for the Indian market's infrastructure constraints
- **Security**: Implement robust security measures for user data and API integrations

---

## 2. DATABASE MIGRATION PATTERNS

### Migration Creation Guidelines
```bash
# Create new migration with descriptive name
alembic revision --autogenerate -m "Add campaign optimization settings table"

# Manual migration for complex changes
alembic revision -m "Add performance indexes for analytics"

# Rollback migrations
alembic downgrade -1
```

---

## 2. CODE ORGANIZATION STANDARDS

### Backend Structure
```
backend/
├── main.py                 # FastAPI application entry
├── core/
│   ├── config.py          # Configuration management
│   ├── database.py        # Database connection
│   └── security.py        # Auth and encryption
├── models/                # SQLAlchemy models
│   ├── __init__.py
│   ├── user.py           # User and subscription models
│   ├── campaign.py       # Campaign related models
│   ├── creative.py       # Creative assets models
│   └── analytics.py      # Performance analytics models
├── services/              # Business logic layer
│   ├── __init__.py
│   ├── auth_service.py   # Authentication logic
│   ├── creative_service.py # Creative generation
│   ├── campaign_service.py # Campaign management
│   ├── meta_api_service.py # Meta API integration
│   └── ai_service.py     # AI processing
├── agents/                # AI agents
│   ├── __init__.py
│   ├── photo_agent.py    # Image generation
│   ├── video_agent.py    # Video generation
│   └── brand_analyzer.py # Brand voice analysis
├── api/                   # REST API endpoints
│   ├── __init__.py
│   ├── auth.py          # Authentication endpoints
│   ├── creatives.py     # Creative Studio API
│   ├── campaigns.py     # Campaign management API
│   └── analytics.py     # Analytics API
├── utils/                 # Shared utilities
│   ├── __init__.py
│   ├── file_storage.py   # S3 operations
│   ├── encryption.py     # Data encryption
│   └── validators.py     # Input validation
└── tests/                 # Test suites
    ├── unit/             # Unit tests
    ├── integration/      # Integration tests
    └── e2e/              # End-to-end tests
```

### Frontend Structure
```
frontend/
├── src/
│   ├── components/        # Reusable components
│   │   ├── common/       # Shared UI components
│   │   ├── creative/     # Creative Studio components
│   │   ├── campaign/     # Campaign management
│   │   └── analytics/    # Dashboard components
│   ├── pages/            # Page components
│   │   ├── Dashboard.tsx
│   │   ├── CreativeStudio.tsx
│   │   ├── Campaigns.tsx
│   │   └── Analytics.tsx
│   ├── services/         # API communication
│   │   ├── api.ts       # Base API configuration
│   │   ├── auth.ts      # Authentication API
│   │   ├── creative.ts  # Creative Studio API
│   │   └── campaign.ts  # Campaign API
│   ├── store/           # State management
│   │   ├── auth.ts      # Authentication state
│   │   ├── creative.ts  # Creative library state
│   │   └── campaign.ts  # Campaign state
│   ├── hooks/           # Custom React hooks
│   ├── utils/           # Helper functions
│   └── types/           # TypeScript interfaces
├── public/              # Static assets
└── tests/               # Frontend tests
```

---

## 3. CODING STANDARDS

### Python Code Style
```python
# Use type hints for all functions
async def create_campaign(
    user_id: UUID,
    campaign_data: CampaignCreate
) -> Campaign:
    """Create a new campaign for the user."""
    pass

# Error handling pattern
try:
    result = await service_operation()
    return {"success": True, "data": result}
except ValidationError as e:
    raise HTTPException(status_code=400, detail=str(e))
except Exception as e:
    logger.error(f"Unexpected error: {e}")
    raise HTTPException(status_code=500, detail="Internal server error")

# Async/await for all I/O operations
async def generate_image(prompt: str) -> str:
    async with httpx.AsyncClient() as client:
        response = await client.post(AI_API_URL, json={"prompt": prompt})
        return response.json()["image_url"]
```

### TypeScript Code Style
```typescript
// Use interfaces for all data structures
interface Campaign {
  id: string;
  name: string;
  purpose: CampaignPurpose;
  dailyBudget: number;
  status: CampaignStatus;
}

// Error handling with try-catch
const createCampaign = async (campaignData: CampaignCreate): Promise<Campaign> => {
  try {
    const response = await api.post('/campaigns', campaignData);
    return response.data;
  } catch (error) {
    if (error.response?.status === 400) {
      throw new Error('Invalid campaign data');
    }
    throw new Error('Failed to create campaign');
  }
};

// Use React Query for API state management
const useCampaigns = () => {
  return useQuery({
    queryKey: ['campaigns'],
    queryFn: () => campaignService.getCampaigns(),
  });
};
```

---

## 4. DATABASE PATTERNS

### Model Definition Pattern
```python
# SQLAlchemy model example
class Campaign(Base):
    __tablename__ = "campaigns"
    
    id: Mapped[UUID] = mapped_column(
        UUID(as_uuid=True), 
        primary_key=True, 
        default=uuid.uuid4
    )
    user_id: Mapped[UUID] = mapped_column(
        UUID(as_uuid=True), 
        ForeignKey("users.id"), 
        nullable=False
    )
    name: Mapped[str] = mapped_column(String(255), nullable=False)
    purpose: Mapped[CampaignPurpose] = mapped_column(
        Enum(CampaignPurpose), 
        nullable=False
    )
    
    # Relationships
    user: Mapped["User"] = relationship(back_populates="campaigns")
    assets: Mapped[List["CampaignAsset"]] = relationship(
        back_populates="campaign",
        cascade="all, delete-orphan"
    )
    
    # Timestamps
    created_at: Mapped[datetime] = mapped_column(default=datetime.utcnow)
    updated_at: Mapped[datetime] = mapped_column(
        default=datetime.utcnow,
        onupdate=datetime.utcnow
    )
```

### Database Query Patterns
```python
# Repository pattern for database operations
class CampaignRepository:
    def __init__(self, db: AsyncSession):
        self.db = db
    
    async def create(self, campaign_data: CampaignCreate) -> Campaign:
        campaign = Campaign(**campaign_data.dict())
        self.db.add(campaign)
        await self.db.commit()
        await self.db.refresh(campaign)
        return campaign
    
    async def get_by_user(self, user_id: UUID) -> List[Campaign]:
        result = await self.db.execute(
            select(Campaign)
            .where(Campaign.user_id == user_id)
            .order_by(Campaign.created_at.desc())
        )
        return result.scalars().all()
    
    async def get_with_performance(self, campaign_id: UUID) -> Optional[Dict]:
        result = await self.db.execute(
            select(
                Campaign,
                func.sum(PerformanceAnalytics.spend).label("total_spend"),
                func.sum(PerformanceAnalytics.conversions).label("total_conversions")
            )
            .join(PerformanceAnalytics, Campaign.id == PerformanceAnalytics.campaign_id)
            .where(Campaign.id == campaign_id)
            .group_by(Campaign.id)
        )
        return result.first()
```

---

## 5. API DEVELOPMENT PATTERNS

### FastAPI Endpoint Pattern
```python
# API endpoint structure
@router.post("/campaigns", response_model=CampaignResponse)
async def create_campaign(
    campaign_data: CampaignCreate,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
) -> CampaignResponse:
    """Create a new campaign for the authenticated user."""
    
    # Validate user subscription limits
    await validate_subscription_limits(current_user, "campaigns")
    
    # Business logic through service layer
    campaign = await CampaignService(db).create_campaign(
        user_id=current_user.id,
        campaign_data=campaign_data
    )
    
    # Log user action for analytics
    await log_user_action(
        user_id=current_user.id,
        action="campaign_created",
        resource_id=campaign.id
    )
    
    return CampaignResponse.from_orm(campaign)

# Error handling middleware
@app.exception_handler(ValidationError)
async def validation_exception_handler(request: Request, exc: ValidationError):
    return JSONResponse(
        status_code=400,
        content={
            "success": False,
            "error": {
                "code": "VALIDATION_ERROR",
                "message": "Invalid input data",
                "details": exc.errors()
            }
        }
    )
```

### Service Layer Pattern
```python
# Business logic in service layer
class CampaignService:
    def __init__(self, db: AsyncSession):
        self.db = db
        self.campaign_repo = CampaignRepository(db)
        self.meta_api = MetaAPIService()
    
    async def create_campaign(
        self, 
        user_id: UUID, 
        campaign_data: CampaignCreate
    ) -> Campaign:
        """Create campaign with Meta API integration."""
        
        # Create campaign in database
        campaign = await self.campaign_repo.create(
            user_id=user_id,
            campaign_data=campaign_data
        )
        
        # Create campaign in Meta API (background job)
        await create_meta_campaign.delay(campaign.id)
        
        return campaign
    
    async def optimize_campaign(self, campaign_id: UUID) -> OptimizationResult:
        """AI-powered campaign optimization."""
        
        # Get campaign performance data
        performance = await self.get_performance_data(campaign_id)
        
        # AI optimization logic
        if performance.roas > 4.0 and performance.days_running >= 3:
            # Increase budget by 50%
            new_budget = performance.current_budget * 1.5
            await self.update_budget(campaign_id, new_budget)
            
        return OptimizationResult(
            action="budget_increase",
            old_value=performance.current_budget,
            new_value=new_budget,
            reason="ROAS above 4x for 3+ days"
        )
```

---

## 6. AI INTEGRATION PATTERNS

### AI Service Pattern
```python
# AI service with error handling and retries
class AIService:
    def __init__(self):
        self.client = genai.Client(api_key=settings.GOOGLE_API_KEY)
        self.max_retries = 3
        self.retry_delay = 1
    
    async def generate_image(
        self, 
        prompt: str, 
        style: str = "modern", 
        format: str = "1:1"
    ) -> str:
        """Generate image with retry logic."""
        
        for attempt in range(self.max_retries):
            try:
                response = await self.client.models.generate_images(
                    model='imagen-4.0-generate-001',
                    prompt=self._enhance_prompt(prompt, style),
                    config=types.GenerateImagesConfig(
                        number_of_images=1,
                        aspect_ratio=format
                    )
                )
                
                if response.generated_images:
                    image_url = await self._save_generated_image(
                        response.generated_images[0]
                    )
                    return image_url
                    
            except Exception as e:
                if attempt < self.max_retries - 1:
                    await asyncio.sleep(self.retry_delay * (2 ** attempt))
                    continue
                raise AIServiceError(f"Failed to generate image: {str(e)}")
        
        raise AIServiceError("Max retries exceeded")
    
    def _enhance_prompt(self, prompt: str, style: str) -> str:
        """Enhance prompt with style and marketing context."""
        return f"""
        Create a {style} style marketing image: {prompt}
        
        Requirements:
        - Professional quality suitable for advertising
        - Eye-catching visuals for social media marketing
        - High production value for commercial use
        """
```

### Background Job Pattern
```python
# Celery tasks for long-running operations
@celery.task(bind=True, max_retries=3)
def generate_campaign_assets(self, campaign_id: str, asset_count: int):
    """Background task to generate multiple assets for campaign."""
    
    try:
        campaign = Campaign.get(campaign_id)
        ai_service = AIService()
        
        for i in range(asset_count):
            # Update progress
            self.update_state(
                state='PROGRESS',
                meta={'current': i, 'total': asset_count}
            )
            
            # Generate asset
            asset_url = ai_service.generate_image(
                prompt=campaign.get_ai_prompt(),
                style=campaign.brand_profile.style
            )
            
            # Save to database
            CampaignAsset.create(
                campaign_id=campaign_id,
                asset_url=asset_url,
                asset_type='image'
            )
    
    except Exception as exc:
        raise self.retry(exc=exc, countdown=60)
```

---

## 7. FRONTEND PATTERNS

### Component Structure
```tsx
// Reusable component pattern
interface CampaignCardProps {
  campaign: Campaign;
  onEdit: (campaign: Campaign) => void;
  onDelete: (campaignId: string) => void;
}

const CampaignCard: React.FC<CampaignCardProps> = ({ 
  campaign, 
  onEdit, 
  onDelete 
}) => {
  const { data: performance } = useCampaignPerformance(campaign.id);
  
  return (
    <div className="campaign-card">
      <h3>{campaign.name}</h3>
      <div className="performance">
        <span>ROAS: {performance?.roas || 'N/A'}</span>
        <span>Spend: ₹{performance?.spend || 0}</span>
      </div>
      <div className="actions">
        <button onClick={() => onEdit(campaign)}>Edit</button>
        <button onClick={() => onDelete(campaign.id)}>Delete</button>
      </div>
    </div>
  );
};
```

### State Management Pattern
```tsx
// Zustand store pattern
interface CreativeStore {
  assets: CreativeAsset[];
  selectedAssets: string[];
  isGenerating: boolean;
  
  // Actions
  fetchAssets: () => Promise<void>;
  generateAsset: (prompt: string, format: string) => Promise<void>;
  selectAsset: (assetId: string) => void;
  unselectAsset: (assetId: string) => void;
}

const useCreativeStore = create<CreativeStore>((set, get) => ({
  assets: [],
  selectedAssets: [],
  isGenerating: false,
  
  fetchAssets: async () => {
    const assets = await creativeService.getAssets();
    set({ assets });
  },
  
  generateAsset: async (prompt: string, format: string) => {
    set({ isGenerating: true });
    try {
      const asset = await creativeService.generateImage({ prompt, format });
      set(state => ({ 
        assets: [asset, ...state.assets],
        isGenerating: false 
      }));
    } catch (error) {
      set({ isGenerating: false });
      throw error;
    }
  },
  
  selectAsset: (assetId: string) => {
    set(state => ({
      selectedAssets: [...state.selectedAssets, assetId]
    }));
  },
}));
```

---

## 8. TESTING PATTERNS

### Unit Testing
```python
# pytest unit test example
import pytest
from unittest.mock import AsyncMock
from services.campaign_service import CampaignService

class TestCampaignService:
    @pytest.fixture
    def mock_db(self):
        return AsyncMock()
    
    @pytest.fixture
    def campaign_service(self, mock_db):
        return CampaignService(mock_db)
    
    @pytest.mark.asyncio
    async def test_create_campaign_success(self, campaign_service):
        # Arrange
        campaign_data = CampaignCreate(
            name="Test Campaign",
            purpose="lead_generation",
            daily_budget=1000.00
        )
        
        # Act
        result = await campaign_service.create_campaign(
            user_id="test-user-id",
            campaign_data=campaign_data
        )
        
        # Assert
        assert result.name == "Test Campaign"
        assert result.purpose == "lead_generation"
```

### Integration Testing
```python
# FastAPI test client
import pytest
from httpx import AsyncClient
from main import app

class TestCampaignAPI:
    @pytest.mark.asyncio
    async def test_create_campaign(self):
        async with AsyncClient(app=app, base_url="http://test") as client:
            # Login first
            login_response = await client.post("/auth/login", json={
                "email": "test@example.com",
                "password": "testpass"
            })
            token = login_response.json()["access_token"]
            
            # Create campaign
            response = await client.post(
                "/campaigns",
                json={
                    "name": "Test Campaign",
                    "purpose": "lead_generation",
                    "daily_budget": 1000.00
                },
                headers={"Authorization": f"Bearer {token}"}
            )
            
            assert response.status_code == 201
            assert response.json()["name"] == "Test Campaign"
```

### Frontend Testing
```tsx
// React Testing Library
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import CampaignForm from '../CampaignForm';

describe('CampaignForm', () => {
  const queryClient = new QueryClient();
  
  const renderComponent = (props = {}) => {
    return render(
      <QueryClientProvider client={queryClient}>
        <CampaignForm {...props} />
      </QueryClientProvider>
    );
  };
  
  test('creates campaign successfully', async () => {
    const onSubmit = jest.fn();
    renderComponent({ onSubmit });
    
    fireEvent.change(screen.getByLabelText(/campaign name/i), {
      target: { value: 'Test Campaign' }
    });
    
    fireEvent.click(screen.getByRole('button', { name: /create campaign/i }));
    
    await waitFor(() => {
      expect(onSubmit).toHaveBeenCalledWith({
        name: 'Test Campaign',
        purpose: 'lead_generation'
      });
    });
  });
});
```

---

## 9. PERFORMANCE OPTIMIZATION

### Database Query Optimization
```python
# Use select_in_loading for N+1 queries
campaigns = await db.execute(
    select(Campaign)
    .options(selectinload(Campaign.assets))
    .where(Campaign.user_id == user_id)
)

# Use indexed columns in WHERE clauses
# Add composite indexes for common query patterns
# Use EXPLAIN ANALYZE to analyze query performance

# Cache expensive queries
@cached(ttl=300)  # Cache for 5 minutes
async def get_campaign_analytics(campaign_id: UUID) -> Dict:
    return await expensive_analytics_query(campaign_id)
```

### API Response Optimization
```python
# Use response models to control data serialization
class CampaignListResponse(BaseModel):
    campaigns: List[CampaignSummary]  # Only essential fields
    total_count: int
    has_more: bool

# Implement pagination for large datasets
@router.get("/campaigns")
async def get_campaigns(
    limit: int = Query(20, le=100),
    offset: int = Query(0, ge=0)
):
    campaigns = await campaign_service.get_paginated(limit, offset)
    return campaigns
```

---

## 10. DEPLOYMENT PATTERNS

### Docker Configuration
```dockerfile
# Backend Dockerfile
FROM python:3.13-slim

WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

### Environment Configuration
```python
# Use Pydantic settings for configuration
class Settings(BaseSettings):
    database_url: str
    redis_url: str
    google_api_key: str
    facebook_app_id: str
    facebook_app_secret: str
    secret_key: str
    
    class Config:
        env_file = ".env"

settings = Settings()
```

This implementation guide provides the foundation for consistent, maintainable, and scalable development of the AI marketing automation platform.